#!/usr/bin/env bash
# MIT License

# Copyright 2018 Adam Schaefers sch@efers.org

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

usage() {
    cat << EOF
Usage:
        themelios configuration.sh git-remote [branch]

Use -h or --help for more information.
EOF
    exit
}

help() {
    cat <<EOF
Example command:
         themelios configuration.sh https://github.com/a-schaefers/themelios.git master

This command will download the a-schaefers/themelios repo from github, then
check out the master branch, then search the project for a file by the name of "configuration.sh",
and then finally begin the bootstrap process with no-questions-asked beyond "are you sure?"

Github users may also use a shorthand:
        themelios configuration.sh a-schaefers/themelios

Specificying the [branch] is optional in all cases.

"configuration.sh" may actually be named anything and located anywhere in the project.
Themelios will find it automatically. This allows for using multiple, per-machine
configuration.sh files, provided they are uniquely named.

In summary, feed Themelios a git repository url and the name of any file which
[only] contains the following configuration variables:

# Themelios configuration.sh example
POOL_NAME="zroot"
POOL_TYPE="raidz1"    # May also be set to "mirror". Leave empty "" for single.

# use one disk per line here!
POOL_DISKS="/dev/sda
/dev/sdb
/dev/sdc"

SGDISK_CLEAR="true"   # Use sgdisk --clear
WIPEFS_ALL="true"     # Use wipefs --all
ZERO_DISKS="false"    # Use dd if=/dev/zero ...
ATIME="off"           # Set to "on" or "off" (recommended "off" for SSD.)
SNAPSHOT_ROOT="true"  # Set the value of com.sun:auto-snapshot
SNAPSHOT_HOME="true"
USE_ZSWAP="false"     # Creates a swap zvol
ZSWAP_SIZE="4G"

# Your top-level configuration.nix file-- (use the relative path from the project_root.)
# For example, to bootstrap the file project_root/hosts/vm-example/default.nix use the following:
TOP_LEVEL_NIXFILE="hosts/vm-example"

# Directory name of <git-remote> in "/" (root). Do not use slashes.
NIXCFG_DIR="nix-config"

# If true, mount /nix outside of the / (root) dataset.
# Setting this to true would trade-off the ability to use zfs boot environments for extra disk space.
# If you use nix.gc.automatic, then this should not be much of an issue. Recommended "false".
NIXDIR_NOROOT="false" # mount /nix outside of the / (root) dataset.

# Creates /etc/nixos/themelios-zfs.nix with sensible settings
THEMELIOS_ZFS="true"

# Enable ZFS_CARE Options? (Only enable this if THEMELIOS_ZFS="true" also.)
THEMELIOS_ZFS_CARE="false"

####################
# ZFS_CARE Options #
####################

# Auto Scrubs
care_autoScrub="true"

# Auto Snapshots
care_autoSnapshot_enabled="true"
care_autoSnapshot_frequent="8" # Take a snapshot every 15 minutes and keep 8 in rotation
care_autoSnapshot_hourly="0"
care_autoSnapshot_daily="7" # Take a daily snapshot and keep 7 in rotation
care_autoSnapshot_weekly="0"
care_autoSnapshot_monthly="0"

# Auto Garbage Collection
care_gc_automatic="true"
care_gc_dates="daily"
care_gc_options="--delete-older-than 7d"

# Auto /tmp clean
care_cleanTmpDir="true"
EOF
    exit
}

[[ $1 == "-h" ]] && help
[[ $1 == "--help" ]] && help
[[ $# -lt 2 ]] && usage
[[ $# -gt 3 ]] && usage
NIXCFG_HOST=$1
NIXCFG_REPO=$2
NIXCFG_BRANCH=$3

__initial_warning() {
    echo "WARNING: The following script intends to replace all of your disk(s) \
contents with a zfs-on-root NixOS installation and bootstrap your configuration.nix."
    read -p "Ready? (Y or N) " -n 1 -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        echo "Aborted." ; exit
    fi
}

__fail_warning() {
    read -p "The previous command failed. Continue running script? (Y or N) " -n 1 -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        echo "Aborted." ; exit
    fi
}

__uefi_or_legacy() {
    # TODO add uefi support.
    if [ -d "/sys/firmware/efi/efivars" ]; then
        exit ; echo "Only legacy bios is supported with this script for now."
    fi
}

__switch_if_needed() {
    if [[ ${NEEDS_SWITCH} == "true" ]]
    then
        nixos-rebuild switch || echo "nixos-rebuild switch from switch_if_needed failed" ; __fail_warning
        NEEDS_SWITCH="false"
    fi
}

__bootstrap_zfs() {
    __install_zfs() {
        sed -i '/imports/a \
boot.supportedFilesystems = [ \"zfs\" ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which zfs > /dev/null 2>&1 || __install_zfs
}

__bootstrap_git() {
    __install_git() {
        sed -i '/imports/a \
 environment.systemPackages = with pkgs; [ git ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which git > /dev/null 2>&1 || __install_git
}

__get_custom_nixcfg() {
    # git clone the declared repo from NIXCFG_REPO ($2)
    # github users https remote will be switched to ssh remote automatically after initial clone.
    # github users also may use "shorthand" USERNAME/REPO-NAME
    # optional NIXFG_BRANCH ($3) may be used additionally for users who need to build from a non-master branch.
    GH_SHORTHAND=$(echo ${NIXCFG_REPO} | grep -v ".git")
    GITHUB_URL=$(echo ${NIXCFG_REPO} | grep "github.com")
    __checkout_branch() {
        echo "Checking out ${GITHUBSSHREMOTE}"
        cd /tmp/NIXCFG_REPO
        git checkout ${NIXCFG_BRANCH}
    }
    __switch_github_remotes() {
        echo "Switching remote from https to ${GITHUBSSHREMOTE} for user convenience..."
        cd /tmp/NIXCFG_REPO
        git remote set-url origin ${GITHUBSSHREMOTE}
    }
    __github_clone_and_switch() {
        echo "Cloning repo via ${GITHUBHTTPSREMOTE}"
        GITHUBHTTPSREMOTE=https://github.com/${GITHUB_USER}/${GITHUB_REPO}
        GITHUBSSHREMOTE=git@github.com:${GITHUB_USER}/${GITHUB_REPO}
        git clone ${GITHUBHTTPSREMOTE} /tmp/NIXCFG_REPO || __fail_warning
        __switch_github_remotes
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    }
    if [[ ${GITHUB_URL} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 4)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 5)
        __github_clone_and_switch
    elif [[ ${GH_SHORTHAND} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | cut -d '/' -f 1)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | cut -d '/' -f 2)
        __github_clone_and_switch
    else
        echo "Cloning repo via ${NIXCFG_REPO}"
        git clone ${NIXCFG_REPO} /tmp/NIXCFG_REPO || __fail_warning
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    fi

    # find NIXCFG_HOST ($1) and source the variables
    echo "Extracting configuration variables..."
    NIXCFG_HOST=$(cd /tmp/NIXCFG_REPO && find -name "${NIXCFG_HOST}")
    source "${NIXCFG_HOST}" || __fail_warning
    cat <<EOF
${NIXCFG_HOST}
EOF
}

__disk_prep() {
    if [[ ${SGDISK_CLEAR} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Clearing disk with sgdisk..."
            sgdisk --clear ${DISK_ID} || __fail_warning
        done
    fi

    if [[ ${WIPEFS_ALL} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Wiping disk signatures with wipefs..."
            wipefs --all ${DISK_ID} || __fail_warning
        done
    fi

    if [[ ${ZERO_DISKS} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Writing Zeros to each disk, this may take a while..."
            dd if=/dev/zero of=${DISK_ID} bs=4096 status=progress
        done
    fi
}

__zpool_create() {
    echo "Creating zpool..."
    zpool create -f \
          -o ashift=12 \
          -O compression=lz4 \
          -O atime=${ATIME:?"Please define atime."} \
          -O relatime=on \
          -O normalization=formD \
          -O xattr=sa \
          -m none \
          -R /mnt \
          ${POOL_NAME:?"Please define pool name."} \
          ${POOL_TYPE} \
          ${POOL_DISKS:?"Please define pool disks."} || __fail_warning

    IFS=$'\n'
    for DISK_ID in ${POOL_DISKS}
    do
        echo "Creating BIOS boot partition..."
        sgdisk -a1 -n2:48:2047 -t2:EF02 -c2:"BIOS boot partition" ${DISK_ID} || __fail_warning
        partx -u ${DISK_ID}
    done
}

__datasets_create() {
    echo "Creating and mounting datasets in /mnt..."
    # / (root) datasets
    zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/ROOT
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/ROOT/nixos
    mount -t zfs ${POOL_NAME}/ROOT/nixos /mnt
    zpool set bootfs=${POOL_NAME}/ROOT/nixos ${POOL_NAME}

    # TRADEOFF Disk space vs. Robustness. imo-- just garbage collect more often and don't use this option.
    # /nix optional dataset outside of / dataset (I don't like this idea, but set this variable if you want.)
    # Save some potential disk space at the cost of losing ZFS boot environments (less robust.)
    __slash_nix_outside_root() {
        zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/NIX
        zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/NIX/nix
        mkdir /mnt/nix
        mount -t zfs ${POOL_NAME}/NIX/nix /mnt/nix
    }
    if [[ ${NIXDIR_NOROOT} == "true" ]]
    then
        __slash_nix_outside_root
    fi

    mkdir -p /mnt/{home,tmp}

    # /home datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/HOME
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/HOME/home
    mount -t zfs ${POOL_NAME}/HOME/home /mnt/home

    # /tmp datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/TMP
    zfs create -o mountpoint=legacy -o canmount=on -o sync=disabled ${POOL_NAME}/TMP/tmp
    mount -t zfs ${POOL_NAME}/TMP/tmp /mnt/tmp

    # zswap option
    if [[ ${USE_ZSWAP} == "true" ]]
    then
        echo "Creation ZSWAP volume and turning on swap..."
        zfs create \
            -o primarycache=metadata \
            -o secondarycache=metadata \
            -o compression=zle \
            -o sync=always \
            -o logbias=throughput \
            -o com.sun:auto-snapshot=false \
            ${POOL_NAME}/SWAP

        zfs create \
            -V ${ZSWAP_SIZE} \
            -b $(getconf PAGESIZE) \
            ${POOL_NAME}/SWAP/swap0

        mkswap -f /dev/zvol/${POOL_NAME}/SWAP/swap0
        swapon /dev/zvol/${POOL_NAME}/SWAP/swap0
    fi
}

 __zfs_auto_snapshot() {
     if [[ ${SNAPSHOT_HOME} == "true" ]]
     then
         echo "Setting com.sun:auto-snapshot=true for HOME datasets..."
         zfs set com.sun:auto-snapshot=true ${POOL_NAME}/HOME
     elif [[ ${SNAPSHOT_ROOT} == "false" ]]
     then
         echo "Setting com.sun:auto-snapshot=false for HOME datasets..."
         zfs set com.sun:auto-snapshot=false ${POOL_NAME}/HOME
     fi

     if [[ ${SNAPSHOT_ROOT} == "true" ]]
     then
         echo "Setting com.sun:auto-snapshot=true for ROOT datasets..."
         zfs set com.sun:auto-snapshot=true ${POOL_NAME}/ROOT
     elif [[ ${SNAPSHOT_ROOT} == "false" ]]
     then
         echo "Setting com.sun:auto-snapshot=false for ROOT datasets..."
         zfs set com.sun:auto-snapshot=false ${POOL_NAME}/ROOT
     fi
 }

 __bootstrap_nixcfg() {
     echo "Moving repo from /tmp to /mnt..."
     cp -rp /tmp/NIXCFG_REPO /mnt/${NIXCFG_DIR}

     echo "Executing nixos-generate-config --root /mnt"
     nixos-generate-config --root /mnt || __fail_warning

     [[ ! ${POOL_HOSTID} ]] && POOL_HOSTID="random"
     if [[ ${POOL_HOSTID} == "random" ]]
     then
         echo "Generating random hostid..."
         POOL_HOSTID="$(head -c4 /dev/urandom | od -A none -t x4 | cut -d ' ' -f 2)"
         echo "${POOL_HOSTID}"
     fi

     #sanitize TLN for import heredoc
     TOP_LEVEL_NIXFILE=$(echo "${TOP_LEVEL_NIXFILE}" | sed 's|^./||')

    # setup user's future /etc/nixos/configuration.nix file to import their custom TOP_LEVEL_NIXFILE.
    if [[ ${THEMELIOS_ZFS} == "true" ]]
    then
        THEMELIOS_OPTIONAL_GENERATED="./themelios-zfs.nix"
    else
        ZFS_REQUIRED_HOSTID="networking.hostId = \"${POOL_HOSTID}\";"
    fi
    cat <<EOF > /mnt/etc/nixos/configuration.nix
{ ... }:
{ imports = [
../../${NIXCFG_DIR}/${TOP_LEVEL_NIXFILE}
./hardware-configuration.nix
${THEMELIOS_OPTIONAL_GENERATED}
];
${ZFS_REQUIRED_HOSTID}
}
EOF

    [[ ${THEMELIOS_ZFS} == "true" ]] && cat << EOF > /mnt/etc/nixos/themelios-zfs.nix
{ ... }:
{ imports = [];

# some zfs-on-root sensible settings

# configure grub using /dev/disk/by-d and zfs-support
boot.supportedFilesystems = [ "zfs" ];
boot.loader.grub.enable = true;
boot.loader.grub.version = 2;
boot.loader.grub.devices = [
$(IFS=$'\n'
for DISK_ID in ${POOL_DISKS}
do
echo $(echo "\"${DISK_ID}\"")
done)
];

# The 32-bit host ID of the machine, formatted as 8 hexadecimal characters.
# You should try to make this ID unique among your machines.
networking.hostId = "${POOL_HOSTID}";

# noop elevator recommended.
# shell_on_fail allows to force import manually in the case of zfs import failure.
boot.kernelParams = [ "elevator=noop" "boot.shell_on_fail" ];

# grub on ZFS has been known to have a hard time finding kernels with really/long/dir/paths
# Just copy the kernels to /boot and avoid the issue.
boot.loader.grub.copyKernels = true;

# Setting these to false will ensure some safeguards are active that ZFS uses to protect your ZFS pools.
boot.zfs.forceImportAll = false;
boot.zfs.forceImportRoot = false;

$([[ ${THEMELIOS_ZFS_CARE} == "true" ]] && cat <<-CARE
services.zfs.autoScrub.enable = ${care_autoScrub};
services.zfs.autoSnapshot = {
enable = ${care_autoSnapshot_enabled};
frequent = ${care_autoSnapshot_frequent};
hourly = ${care_autoSnapshot_hourly};
daily = ${care_autoSnapshot_daily};
weekly = ${care_autoSnapshot_weekly};
monthly = ${care_autoSnapshot_monthly};
};

# Use gc.automatic with zfs-auto-snapshot to keep disk space under control.
nix.gc.automatic = ${care_gc_automatic};
nix.gc.dates = "${care_gc_dates}";
nix.gc.options = "${care_gc_options}";

# clean /tmp automatically on boot
boot.cleanTmpDir = ${care_cleanTmpDir};
CARE
)
}
EOF

    # nixos-install section
    __nixos-install-show-trace() {
        nixos-install --root /mnt --show-trace || __nixos-install_fail_retry
    }
    __nixos-install_fail_retry() {
        echo "themelios hint: check /mnt/etc/nixos/configuration.nix and your other files in /mnt/${NIXCFG_DIR} before trying again."
        echo "themelios hint: make sure you are using relative path imports for all of your .nix files."
        read -p "nixos-install --root /mnt failed, retry? will add --show-trace (Y or N) " -n 1 -r
        if [[ $REPLY =~ ^[Yy]$ ]]
        then
            __nixos-install-show-trace
        else
            exit
        fi
    }
    __nixos-install() {
        echo "executing nixos-install --root /mnt"
        nixos-install --root /mnt || __nixos-install_fail_retry
    }

    __nixos-install
 }

__thank_you() {
    cat <<EOF
NNNNNNNN        NNNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
N:::::::N       N::::::NI::::::::IX:::::X       X:::::X
N::::::::N      N::::::NI::::::::IX:::::X       X:::::X
N:::::::::N     N::::::NII::::::IIX::::::X     X::::::X
N::::::::::N    N::::::N  I::::I  XXX:::::X   X:::::XXX
N:::::::::::N   N::::::N  I::::I     X:::::X X:::::X
N:::::::N::::N  N::::::N  I::::I      X:::::X:::::X
N::::::N N::::N N::::::N  I::::I       X:::::::::X
N::::::N  N::::N:::::::N  I::::I       X:::::::::X
N::::::N   N:::::::::::N  I::::I      X:::::X:::::X
N::::::N    N::::::::::N  I::::I     X:::::X X:::::X
N::::::N     N:::::::::N  I::::I  XXX:::::X   X:::::XXX
N::::::N      N::::::::NII::::::IIX::::::X     X::::::X
N::::::N       N:::::::NI::::::::IX:::::X       X:::::X
N::::::N        N::::::NI::::::::IX:::::X       X:::::X
NNNNNNNN         NNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
EOF

    __umount_export() {
        if [[ ${USE_ZSWAP} == "true" ]]
        then
            swapoff /dev/zvol/${POOL_NAME}/SWAP/swap0
        fi
        echo "Unmounting /mnt"
        umount /mnt/home
        umount /mnt/tmp
        umount /mnt
        zpool export ${POOL_NAME}
    }
    [[ ! ${NOUMOUNT} ]] && __umount_export

    read -p "Finished. Reboot now? (Y or N) " -n 1 -r
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        reboot
    fi

    exit
}

# debug section

# Pass NOUMOUNT=1 to not unmount /mnt or export the pool after install automatically
# run "STARTOVER=1 POOL=poolname ./themelios foo bar" to rerun the script with a fresh start.
__start_over() {
    umount /mnt/home
    umount /mnt/tmp
    umount /mnt
    rm -rf /tmp/NIXCFG_REPO
    zpool destroy ${POOL}
}
[[ ${STARTOVER} ]] && __start_over

# add exits as necessary here

__uefi_or_legacy       # check for legacy or uefi bios
__initial_warning      # warn user of potential doom
__bootstrap_zfs        # install zfs if needed to the livedisk
__bootstrap_git        # install git if needed to the livedisk
__switch_if_needed     # reconfigure nix livedisk if needed
__get_custom_nixcfg    # download the machine configuration from git
__disk_prep            # use sgdisk wipefs or dd to cleanup old disks
__zpool_create         # create the zpool, make gpt bios boot partition
__datasets_create      # create a zfs dataset layout
__zfs_auto_snapshot    # set com.sun:auto-snapshot properties
__bootstrap_nixcfg     # bootstrap the users custom nix configurations
__thank_you            # may you have a Happy Hacking. :)
